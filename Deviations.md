While dbus-broker aims to keep perfect compatibility to existing D-Bus implementations, the D-Bus specification, as well as the reference implementation, there are several occasions where it deviates. Usually, the reason behind those deviations is to mitigate possible attacks, or to improve performance. The complete list of known deviations is as follows:

* **Reply Policies**: While the reference-implementation supports applying D-Bus policies to method-returns, as well as filtering on whether a reply is expected or not, dbus-broker does not support this. Specifically, dbus-broker only allows expected replies, and those are allowed unconditionally.
_Unexpected-replies_ and _Reply-filtering_ have no known users (nor use-cases), hence support has been dropped.

* **at_console Policies**: D-Bus policies in the `at_console=true` context are ignored by dbus-broker. Moreover, the broker considers all peers `at_console=false`, hence only applies those rules. Inspecting whether a peer is considered `at_console` requires IPC at runtime. However, we strongly believe that an implementation of IPC should never perform recursive IPC at runtime to provide its service. Furthermore, `at_console` rules are deprecated by the reference implementation, and there are suitable replacements like PolKit available.

* **Recursive FD Passing**: The linux kernel allows queuing a socket on itself. If a client passes a message with its own end of the Unix-Domain-Socket as payload, the message will keep the client alive, even if the original client exits and closes its FDs. As such, if the message is directed at itself, there will be no way of disconnecting that client.
While dbus-daemon applies timeouts to pending messages (and thus disconnects some of those clients after 120s), dbus-broker does not cleanup such clients. Instead, dbus-broker allows such clients to "pin themselves" if they wish to, relying on its resource accounting to make sure this cannot be exploited.

* **Direct Activation**: Historically, all activated services were forked and exec'ed by the respective bus implementation. With the introduction of systemd, activated service could opt-in to be run executed by systemd as a systemd service instead. With dbus-broker, direct activation is no longer supported, rather all activation requests are forwarded to systemd. In case no systemd service has been configured for a given dbus service, a TransientUnit is generated and used instead.

* **Capture Sender State for Activation**: When an activated name is acquired, forwarding pending messages to it depends on the state of the original sender, both the policy applied to the sender, and the names it owns. This determines both whether or not the message should be transmitted at all, but also which eavesdroppers should receive a copy of the message. The dbus-broker captures the state (policy and names) of the sending peer at send time, and uses this state at the time of activation. The alternative would be to use the state of the sender at activation, but that would mean that changes a peer makes to its own state (such as dropping or acquiring names), after sending a message, may affect the delivery of the message, and in the worst case, if the sender has disconnected by the time the receiver is activated the message would have to be unconditionally dropped. Intuitively, what this all means is that policy decisions and eavesdropping is performed based on the state of the sender at send, and the receiver at receive. Except for the case of activation, send and receive occurs simultaneously.

* **WIP**